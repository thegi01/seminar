'use strict';
window.onload = function(){ 

var result =  'AABAAC'.match(/(AA|AABAAC|B)/);
js.log(result);
/*
1. 실행결과 [AA,AA]를 거꾸로 패턴을 분석해보면
	- 패턴의 왼쪽에 있는  AA가 매치되므로 AA가 반환되었으며
	- ()로 캡쳐한 값이 반환되었습니다.
	- 나머지는 매치되지 않아 반환되지 않았습니다.
2. AABAAC가 매치되지 않는 이유는 뒤에서 살펴봄
3. 패턴 마지막의 B가 매치 대상에 있는데 매치되지 않는 것은
	- AA로 매치된 인덱스보다 B로 매치된 인덱스가 크기 때문입니다.
	- 즉, 매치 대상에서 AA가 앞에 있기 때문이다.
*/

result =  'AABAAC'.match(/(AA|AABAAC|B)*/);
js.log(result);
/*
1. 앞 코드와 차이는 패턴에 *이 있는 점
	- * 패턴 문자는 지정한 문자가 없어도 매치로 처리하고
	- 있으면 모두 매치합니다.
	- 최대로 매치하려는 특성을 갖고 있습니다.
2. AA가 매치되면 AA를 클로저에 저장합니다.
	- 이 때 포인터는 매치 대상의 B에 위치하게 됩니다.
3. 패턴의 다음 값은 AABAAC이며 매치 대상에 있지만
	- 클로저의 AA에 첨부하면 AABAAC가 되므로 매치되지 않습니다.
	- 이렇게 연결하여 매치하는 것은 하나라도 더 매치하려는 특성 때문
4. 패턴 끝에 B가 있으며 클로저의 AA에 연결하면 AAB가 됩니다.
	- 매치 대사에 AAB가 더 많이 매치되므로 현 시점에서 반환값은 AAB이다.
5. 현재 AAC의 A에 포인터가 있으며 패턴을 모두 매치한 상태입니다.
6. 패턴을 끝까지 매치하였다고 끝내지 않습니다.
	- 최대로 매치하려는 특성으로 인해
	- 포인터가 가리키고 있는 인덱스부터 AA를 매치합니다.
	- 매치가 되므로 클로저의 최종 값에 첨부하여 매치합니다.
	- 즉 AABAA로 매치합니다.
	- 매치가 되며 이 시점은 반환값은 [AABAA, AA]가 됩니다.
7. 아직 B가 남았으므로 클로저의 AABAA에 B를 첨부하여 매치합니다.
	- 매치가 되지 않으므로 매치된 최종값인 [AABAA, AA]를 반환합니다.
*/

}


